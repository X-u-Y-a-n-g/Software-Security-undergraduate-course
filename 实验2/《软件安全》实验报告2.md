# 《软件安全》实验报告

姓名：许洋   学号：2313721  班级：1070

## **实验名称：**

OLLYDBG软件破解

##  **实验要求：**

1.请在XP VC6生成课本第三章软件破解的案例(DEBUG模式，示例3-1) 。进而，使用OllyDBG进行单步调试，获取verifyPWD函数对应flag==0的汇编代码，并对这些汇编代码进行解释。

 2.对生成的DEBUG程序进行破解，复现课本上提供的两种破解方法。

## **实验过程：**

###### 一、初步测试

 1.在VC6上建立源文件，输入实验源码后，编译生成可执行的.exe文件，并进行测试。

  ![20250315-162324](D:\许洋计算机科学与技术\软件安全\作业\实验2\20250315-162324.jpg)

 如图可看出当输入的密码不正确时，会输出“wrong password”，并持续重复输入，无法进入程序内部。我们需要对软件进行破解，实现错误密码也可进入程序。

 2.我们使用ollydbg，将lab2.exe文件拖入ollydbg进行动态调试。导入后如下图所示。

  ![20250315-162752](D:\许洋计算机科学与技术\软件安全\作业\实验2\20250315-162752.jpg)

 开始进行破解操作。

######  二、对verifyPwd函数的具体解释

 首先，verifyPWD是一个密码验证程序，我们需要对密码验证程序的逻辑进行修改，使得我们能通过检验进入程序内部。由于提示中的wrong以及指导wrong代表错误逻辑，所以我们先进行关键字查询，看看有没有出现“wrong”之类的关键词来定位函数位置。而且，我们发现这个密码正确或者是错误的判断是从上面的一句汇编语句jz short 00401105来决定的。

  ![20250315-163055](D:\许洋计算机科学与技术\软件安全\作业\实验2\20250315-163055.jpg)

 ![20250315-163429](D:\许洋计算机科学与技术\软件安全\作业\实验2\20250315-163429.jpg)

为了找到verifyPwd函数的核心判断逻辑位置，我们在call函数处右键选择“跟随”，在跟随两次后，我们找到了该函数的位置。 经过搜索，我们发现verifyPwd函数就是从此处开始的。

![20250316-161305](D:\许洋计算机科学与技术\软件安全\作业\实验2\20250316-161305.jpg)

 核心代码：

```assembly
mov eax,dword ptr [ebp+8]
push eax
push offset 0043101C                  ; ASCII "12345678"
call strcmp                       ; [strcmp
add esp,8
mov dword ptr [ebp-4],eax
xor eax,eax
cmp dword ptr [ebp-4],0
sete al
```

 首先将输入的密码的首地址移入eax中，空出8个位置，然后将eax入栈，将待比对的正确密码（12345678）入栈，接着调用strcmp函数比对两个字符串是否相等，如果两个字符串相等，则eax的值为0，如果两个字符串不相等，则eax的值不为0，调整栈指针 esp，将栈顶指针增加 8 字节，以清理栈中的两个参数（每个参数 4 字节），然后将strcmp的结果从eax中移送到局部变量中，并通过xor将eax寄存器的值清空。最后将局部变量的值和0进行比较，如果相等的话就会设置ZF为1，否则ZF为0，并且根据ZF的值设置eax的低八位，如果ZF为1，就设置al为1，反之al被置0。

######  三、两种破解方法

3.1 修改主函数中的条件跳转指令

 我们回到上面的verifyPwd函数部分的判定密码是否正确的部分，可以发现，基本上是由一个jz的判定语句构成的。

 ![20250315-163429](D:\许洋计算机科学与技术\软件安全\作业\实验2\20250315-163429.jpg)

  我们发现00401105语句是用于输出密码错误的，004010F6语句是用于输出密码通过测试。

  所以，程序的逻辑是：如果输入密码符合，那么跳转到“passed”语句，否则跳转到“wrong”语句。因此，我们可以修改逻辑判断语句jz short 00401105为jnz short 00401105，这样就可以实现密码错误跳转，输入错误的密码会跳转到“passed”语句，然后进入程序。

  我们双击该语句，进行修改，然后右键选择“编辑”，选择“复制当前修改到所有可执行文件”，这样才是真正修改了我们的.exe文件。我们修改完毕后，重新打开.exe文件，输入原本是错误的密码“12”，运行成功，说明我们的修改起了作用。

 ![20250316-163916](D:\许洋计算机科学与技术\软件安全\作业\实验2\20250316-163916.jpg)

 为了进一步验证，我们输入原本正确的密码“12345678”，发现输出的是wrong，说明我们已经成功破解了程序。

![20250316-163942](D:\许洋计算机科学与技术\软件安全\作业\实验2\20250316-163942.jpg)

3.2 修改flag==0的返回值指令，令其永远返回1

 接下来我们尝试第二种方法来进行破解。基于我们在第一部分中讨论的flag==0的对应区域汇编代码，我们可以想到另一种更有效地破解方法，那就是让flag==0的返回值永远为1，这样可以避免当输入正确密码而提示密码错误的情况。这样我们就可以实现，不管输入什么密码，都会成功。

![20250316-164207](D:\许洋计算机科学与技术\软件安全\作业\实验2\20250316-164207.jpg)

  根据上面所说的，我们找到flag==0的语句，发现该语句的功能是靠cmp dword ptr [ebp-4],0来实现的。我们直接将其判断函数删除，修改为直接赋值，即直接将al寄存器的值修改为1即可。

  ![20250316-164328](D:\许洋计算机科学与技术\软件安全\作业\实验2\20250316-164328.jpg)

 进一步，我们再来修改下一条语句sete al。我们已经给al寄存器永久赋值为1了，所以我们直接将该语句使用nop指令进行填充即可。

 ![20250316-164411](D:\许洋计算机科学与技术\软件安全\作业\实验2\20250316-164411.jpg)

 我们同样进行编辑保存修改的操作生成.exe文件，运行发现无论输入什么都可以成功。

##  **心得体会：**

通过本次实验，我学会了ollydbg的动态调试方式，包括在整个栈内存中通过跟随操作来跟踪程序的进程；通过查找关键词来定位关键语句；通过修改程序汇编语言代码来实现程序的简单破解。

在这次实验中我发现简单的密码操作可能只是几个判断语句在起作用，经过反汇编的修改完全可以破解掉，这在日常的生活中如果只靠简单的比较是很不安全的，我们应该设置更复杂的逻辑，使得反汇编难以找到具体的错误位置，或者是不单单用简单密码的一重比较来判断是否可以进入程序。在这个过程中加深了我对汇编语言的认识，以及对汇编语言的应用，同时也提高了我的安全认知。