# 《软件安全》实验报告

姓名：许洋   学号：2313721  班级：1070

## **实验名称：**

堆溢出Dword Shoot攻击实验

##  **实验要求：**

 以第四章示例4-4代码为准，在VC IDE中进行调试，观察堆管理结构，记录Unlink节点时的双向空闲链表的状态变化，了解堆溢出漏洞下的Dword Shoot攻击。

## **实验过程：**

#### 1.进入VC反汇编

 我们输入源码，利用Windows的HeapCreate函数来创建堆，进行实验。源码内容如下所示。

```c++
#include<windows.h>
main()
{
    HLOCAL h1, h2,h3,h4,h5,h6;
    HANDLE hp;
    hp = HeapCreate(0,0x1000,0x10000); //创建自主管理的堆
    h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);//从堆里申请空间
    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
    h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
    h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
    h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
    h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);

    _asm int 3 //手动增加int3中断指令，会让调试器在此处中断
    //依次释放奇数堆块，避免堆块合并
    HeapFree(hp,0,h1); //释放堆块
    HeapFree(hp,0,h3); 
    HeapFree(hp,0,h5); //现在freelist[2]有3个元素

    h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 

    return 0;
}
```

我们观察程序，首先创建了一个大小为 0x1000 的堆区，并从其中连续申请了6个块身大小为 8 字节的堆块，加上块首实际上是6个16字节的堆块。

  接着是释放奇数次申请的堆块，这是为了防止堆块的合并。

  三次释放结束后，会形成三个16个字节的空闲堆块放入空表。因为是16个字节，所以会被依次放入freelist[2]所标识的空表，它们依次是h1、h3、h5。

  再次申请8字节的堆区内存，加上块首是16个字节，因此会从freelist[2]所标识的空表中摘取第一个空闲堆块出来，即h1。之后我们只需要通过修改h1的前后向指针就可以观察到Dword Shoot攻击。下面，我们通过设置断点来观察整个攻击的两个指针的变化流程。

####  2.堆管理过程中的内存具体变化

 我们通过在代码中设置断点，来观察内存的变化。

  将鼠标移到第一个块身h1处，观察到其地址为0x003a0688，因为这是块身的起始地址，再减去8就是块首的地址0x003a0680。当执行完h1堆块的释放后，我们跳转到这个地址观察。 ![20250320-105827](D:\许洋计算机科学与技术\软件安全\作业\实验3\20250320-105827.jpg)

 观察0x003a0680开始的内存，前八个字节是块首的一些信息。后八个字节分别是flink和blink对应的内容，可以看到他们都指向了0x003a0198。根据堆块空表的管理方式，我们可以推测出这个地址实际上就是freelist[2]的地址。我们可以跳转到这个地址观察。 ![20250320-105830](D:\许洋计算机科学与技术\软件安全\作业\实验3\20250320-105830.jpg)

 我们发现，freelist[2]的flink和blink均指向了0x003a0688，这就是刚才释放的h1的地址，同时也说明此时这条链上只链入了h1一个空闲堆块，前向指针和后向指针都指向h1。

  接着，我们来完成释放h3的操作，释放后，继续跳转到h1的内存处查看。![20250320-105836](D:\许洋计算机科学与技术\软件安全\作业\实验3\20250320-105836.jpg)

 我们发现，与上一步相比，h1的flink指针位置发生了改变，说明在空表上freelist[2]中又链入了一个空闲堆块，即h3。h1的前向指针此时指向的0x003a06c8就是h3堆块的块身地址。我们跳转到h3所在的地址0x003a06c8查看即可。 ![20250320-111149](D:\许洋计算机科学与技术\软件安全\作业\实验3\20250320-111149.jpg)

 这里，前四个字节是flink的值，指向的就是freelist[2]，后四个字节是blink的值，指向的是h1堆块的块身。这说明此时空表结构为：freelist[2]链接h1链接h3，h3又和freelist[2]双向链接。

  我们继续进行h5的释放，释放完之后，跳转到0x003a0198，即freelist[2]的块身地址查看。 ![20250320-105839](D:\许洋计算机科学与技术\软件安全\作业\实验3\20250320-105839.jpg)

  发现他的blink发生了改变，指向了0x003a0708，这是新链入的h5的地址。我们跳转到该地址查看。![20250320-112256](D:\许洋计算机科学与技术\软件安全\作业\实验3\20250320-112256.jpg)

 可以发现，flink指针所指向的地址依然是freelist[2]，后面的blink指向的是h3的地址，此时，我们已经完成了三个堆块的释放，我们分析出此时块表内存的存储结构应该是：freelist[2]链接h1链接h3链接h5，h5又和freelist[2]双向链接。

 综上所述，此时各个堆块的flink和blink：

|             | flink                   | blink                   |
| ----------- | ----------------------- | ----------------------- |
| Freelist[2] | 0x003a0688(h1)          | 0x003a06708(h5)         |
| h1          | 0x003a06c8(h3)          | 0x003a0198(freelist[2]) |
| h3          | 0x003a0708(h5)          | 0x003a0688(h1)          |
| h5          | 0x003a0198(freelist[2]) | 0x003a06c8(h3)          |

 最后我们重新分配一个块身为8字节的堆。取下第一个空闲堆块h1。这时我们先跳转到0x003a0198，即freelist[2]处，我们发现他的flink变成了0x003a06c8（链接h3），即发生了将h1前向指针的值写入到了h1后向指针所指的地址内存里。 ![20250320-105842](D:\许洋计算机科学与技术\软件安全\作业\实验3\20250320-105842.jpg)

 跳转到0x003a06c8，即h3处，我们发现，我们发现h3堆块的blink变为了0x003a0198（freelist[2]），即发生了将h1后向指针的值写入到h1前向指针所指的地址内存里。 ![20250320-111149](D:\许洋计算机科学与技术\软件安全\作业\实验3\20250320-111149.jpg)

 以上就是完成了Dword Shoot攻击原理的展示。卸下一个堆块的时候，会将其前向指针和后向指针的值写入到其指向的内存当中，因此我们可以利用这个来实现一次Dword Shoot攻击。

## **心得体会：**

在本次实验中，我学会了如何在VC6中建立堆、释放堆。

 在本次实验中，通过跟踪堆块内存位置，我深入理解了堆表的内存管理形式，理解了堆表的合并、空表的链接等知识点，明白了两个指针（flink、blink）的变化形式。

 理解了Dword Shoot的攻击原理，即精心构造一个地址和一个数据，当这个空闲堆块从链表里卸下的时候，就获得一次向内存构造的任意地址写入一个任意数据的机会。