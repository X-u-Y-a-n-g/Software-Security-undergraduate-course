# 《软件安全》实验报告

姓名：许洋   学号：2313721  班级：1070

## **实验名称：**

格式化字符串漏洞

##  **实验要求：**

 以第四章示例4-7代码，完成任意地址的数据获取，观察Release模式和Debug模式的差异，并进行总结。

 实验代码如下所示：

```c++
#include <stdio.h>
int main(int argc, char *argv[])
{
    char str[200];
    fgets(str,200,stdin);
    printf(str);
    return 0;
}
```

## **实验过程：**

#### 一.Debug模式

在vc6中输入源代码，进行debug模式的调试，将.exe文件导入到ollydbg中进行调试。

 在汇编指令中我们向下查找，通过旁边的备注，找到main函数的调用指令，即图中所示的call 00401005。可以在这里按F2打上断点，方便后续误操作进行返回。![20250327-132804.800-2](D:\许洋计算机科学与技术\软件安全\作业\实验4\实验4\20250327-132804.800-2.jpg)

按下F7进行main函数的调试，得到以下的汇编语言代码：![20250327-132804.800-10](D:\许洋计算机科学与技术\软件安全\作业\实验4\实验4\20250327-132804.800-10.jpg)

前六句汇编的意思为，将ebp寄存器压入栈中，然后完成栈顶与栈底的变换，注意到此处赋了108的空间。然后对三个寄存器进行压入，分别是EDI，ESI，EBX

 接下来四句话，是对开辟出的空间全部赋值为CCCCCCCCh。观察右下角可以看到，将空余空间都赋值成为了CCCCCCCCh。![20250327-132804.800-7](D:\许洋计算机科学与技术\软件安全\作业\实验4\实验4\20250327-132804.800-7.jpg)

 接下来，将三个参数入栈，调用函数fgets函数，lea eax,[ebp-0C8]是str的起始地址，在str的起始地址后压入eax寄存器。![20250327-132804.800-3](D:\许洋计算机科学与技术\软件安全\作业\实验4\实验4\20250327-132804.800-3.jpg)

 分析完成后，进行内容的输入，输入AAAA%X%X%X%X，观察栈区，确认已经将其压入栈中。![20250327-132804.800-8](D:\许洋计算机科学与技术\软件安全\作业\实验4\实验4\20250327-132804.800-8.jpg)

接下来执行print函数，其中add esp,0C指令是清除上一个fgets函数所使用的栈帧，然后把str字符串的起始地址存到ecx中，进行入栈。

 我们在执行完程序后，得到了以下的结果。![20250327-132804.800-4](D:\许洋计算机科学与技术\软件安全\作业\实验4\实验4\20250327-132804.800-4.jpg)

即AAAAFFFFFFFE157FFDE000CCCCCCCC

观察我们的栈可以知道，我们在输入AAAA时，程序正常输出四个A；但是当程序遇到后面的%x时，自动读取后面的地址作为输出，因此四个%x对应的输出分别是，FFFFFFFE(FFFFFFFE)、00000015(15)、7FFDE000(7FFDE000)、CCCCCCCC(CCCCCCCC)。所以，对应的程序输出为：AAAAFFFFFFFE157FFDE000CCCCCCCC。这样我们就完成了在debug模式下的调试运行。

#### 二、Release模式

 在VC6中将执行模式切换为release，并将生成的.exe文件导入到ollydbg中，可以直接运行到在debug模式打好的断点进行继续执行。

 按F7进入主函数，我们发现，在release模式下，栈的分配比之前要紧凑了一些，没有多余的空闲栈的多分配，每个变量之间都靠在一起。接下来对代码进行逐条的分析。![20250327-132804.800-12](D:\许洋计算机科学与技术\软件安全\作业\实验4\实验4\20250327-132804.800-12.jpg)

 sub esp，0C8是直接为str字符串分配20字节的内存空间，而后通过三个push操作将fgets函数的三个参数入栈，进行调用。这里，与debug模式有一个区别：无过多的栈内存空间分配，无寄存器的旧值保存。之后我们去寻找函数调用。![20250327-132804.800-13](D:\许洋计算机科学与技术\软件安全\作业\实验4\实验4\20250327-132804.800-13.jpg)

 然后，我们执行fgets函数，输入与debug模式相同的AAAA%X%X%X%X，我们在输入之后观察栈的情况，发现fgets函数的地址与str的地址是紧挨着的，这进一步说明了该模式下，栈分配与debug模式的不同。![20250327-132804.800-9](D:\许洋计算机科学与技术\软件安全\作业\实验4\实验4\20250327-132804.800-9.jpg)

 然后，我们执行print函数，第一行为printf的参数即str字符串的地址0012FEBC，然后执行的时候先输出AAAA，接着四个%X格式化操作符读取后四行的内容作为四个参数进行输出，因此输出结果为AAAA12FEBCBB40603041414141。![20250327-132804.800-11](D:\许洋计算机科学与技术\软件安全\作业\实验4\实验4\20250327-132804.800-11.jpg)

 输出结果如下。在程序函数调用完之后，还有两句汇编语言代码，含义是，将eax寄存器置零，然后将esp寄存器的位置恢复到原始的位置，完成栈帧改的恢复。![20250327-132804.800-1](D:\许洋计算机科学与技术\软件安全\作业\实验4\实验4\20250327-132804.800-1.jpg)

####  三、Debug模式与Release模式的差异

 在完成两个模式下的分析后，我发现这两个模式有以下的不同之处：

#### Debug模式：

- **更大的栈空间分配** ：在Debug模式下，编译器通常会为局部变量分配更多的栈空间，以便进行边界检查和未初始化变量的检测。例如，char str[200]可能会分配超过200字节的空间。
- **初始化未使用的内存** ：为了帮助开发者发现未初始化变量的问题，Debug模式会对栈空间进行统一初始化（如使用rep stos指令将栈空间填充为特定值，如0xCC）。
- **靠近EBP的地址分配** ：局部变量的地址通常从靠近EBP的位置开始分配，因此如果需要访问str的地址，可能需要使用更多的格式化字符（如%X）来跳过其他数据。

#### Release模式：

- **紧凑的栈空间分配** ：Release模式下，编译器会尽量减少栈空间的浪费，只为实际需要的变量分配足够的空间。
- **不进行初始化** ：为了提高性能，Release模式不会对未使用的栈空间进行初始化，这可能导致未初始化变量的行为不可预测。
- **优化后的变量布局** ：编译器可能会重新排列局部变量的顺序以优化内存访问效率，甚至将某些变量直接存储在寄存器中，而不是栈上。

## **心得体会：**

1. **对格式化字符串漏洞的认识**

格式化字符串漏洞是一种常见的安全问题，源于printf等函数未正确处理用户输入的格式化字符串。在实验中，我们通过输入AAAA%X%X%X%X来触发该漏洞，成功读取了栈上的数据。这让我认识到：

**格式化字符串的危险性** ：当开发者直接将用户输入作为printf的第一个参数时，攻击者可以通过构造恶意输入来泄露内存数据，甚至改写内存内容。

**漏洞的隐蔽性** ：这类漏洞往往不会立即导致程序崩溃，而是悄悄暴露敏感信息，因此更容易被忽视。

2. **Debug模式与Release模式的差异**

在实验中，我分别在Debug模式和Release模式下分析了程序的行为，发现了两种模式在栈管理、内存初始化和优化策略上有显著差异：

**Debug模式更适合调试** ：Debug模式通过分配更大的栈空间、初始化未使用的内存（如填充0xCC）以及保存寄存器值等方式，为开发者提供了更高的稳定性和可调试性。这种模式虽然安全性较高，但性能较低。

**Release模式追求性能** ：Release模式通过紧凑的栈分配、省略冗余操作（如不保存寄存器值）以及启用优化技术（如寄存器存储变量），提高了程序的运行效率。然而，这种模式缺乏运行时检查，容易引发未定义行为。

这些差异让我意识到，开发过程中需要根据实际需求选择合适的编译模式，并在发布前进行充分的安全测试。

​			3. **格式化字符串漏洞的防御方法**

通过实验，我总结了一些防御格式化字符串漏洞的方法：

**避免直接使用用户输入作为格式化字符串** ：在调用printf等函数时，应始终指定格式化字符串，例如printf("%s", str)，而不是直接使用printf(str)。

**启用编译器的安全选项** ：现代编译器（如GCC、MSVC）提供了多种安全选项，可以检测并阻止潜在的格式化字符串漏洞。

**代码审计与测试** ：定期对代码进行安全审计，尤其是涉及用户输入的部分；同时利用工具（如静态分析工具、动态分析工具）发现潜在漏洞。

通过本次实验，我不仅掌握了格式化字符串漏洞的基本原理和利用方法，还学会了如何分析程序在不同编译模式下的行为差异。这些知识和技能对我今后的学习和工作具有重要意义。在未来，我将继续努力，不断提升自己的技术水平，为构建更安全的软件系统贡献自己的力量。
