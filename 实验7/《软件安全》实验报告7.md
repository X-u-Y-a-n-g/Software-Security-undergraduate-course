# 《软件安全》实验报告

姓名：许洋   学号：2313721  班级：1070

## **实验名称：**

 AFL模糊测试

##  **实验要求：**

根据课本7.4.5章节，复现AFL在Kali下的安装、应用，查阅资料理解覆盖引导和文件变异的概念和含义。

## **实验过程：**

####  安装AFL

 我们先根据实验要求，进入vmware，开启kali虚拟机，并在其中创建一个新的文件夹demo1。进入文件夹，通过右键菜单，打开终端。

 然后，我们输入命令行wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz，下载安装包。然后我们输入命令行tar xvf afl-latest.tgz，解压安装包。![20250417-112300.401-4](D:\许洋计算机科学与技术\软件安全\作业\实验7\实验7\20250417-112300.401-4.jpg)

 我们通过跳转命令行cd afl-2.52b进入对应的文件夹，然后输入sudo make && sudo make install来编译AFL。![20250417-112300.401-3](D:\许洋计算机科学与技术\软件安全\作业\实验7\实验7\20250417-112300.401-3.jpg)

编译成功，我们输入命令行ls /usr/local/bin来验证是否安装成功。![20250417-112300.401-8](D:\许洋计算机科学与技术\软件安全\作业\实验7\实验7\20250417-112300.401-8.jpg)

 安装成功，并且输出了里面含有的AFL文件。

#### AFL的应用

 接下来，我们利用安装好的AFL文件，复现课本上出现的模糊测试的案例，来进一步加深对于AFL应用的理解。

##### 创建测试程序

 在demo1文件夹中新建一个test.c文件，并输入我们的源码 ：

```c++
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv) {
  char ptr[20];
  if(argc>1){
           FILE *fp = fopen(argv[1], "r");
           fgets(ptr, sizeof(ptr), fp);
  }
  else{
          fgets(ptr, sizeof(ptr), stdin);
  }
  printf("%s", ptr);
  if(ptr[0] == 'd') {
          if(ptr[1] == 'e') {
                  if(ptr[2] == 'a') {
                          if(ptr[3] == 'd') {
                                  if(ptr[4] == 'b') {
                                          if(ptr[5] == 'e') {
                                                  if(ptr[6] == 'e') {
                                                          if(ptr[7] == 'f') {
                                                                  abort();
                                                          }
                                                          else    printf("%c",ptr[7]);
                                                   }
                                                   else    printf("%c",ptr[6]);
                                          }
                                          else    printf("%c",ptr[5]);
                                  }
                                  else    printf("%c",ptr[4]);
                          }
                          else    printf("%c",ptr[3]);
                  }
                  else    printf("%c",ptr[2]);
          }
          else    printf("%c",ptr[1]);
  }
  else    printf("%c",ptr[0]);
  return 0;
}
```

 通过分析代码可知，当输入字符串“deadbeef”时程序捕捉到一个异常，程序终止。

 我们使用linux的编译器进行编译，可以使模糊过程更加高效。我们输入命令行afl-gcc -o test test.c，来对源代码进行编译。发现得到一个编译后的文件。![20250417-112300.401-9](D:\许洋计算机科学与技术\软件安全\作业\实验7\实验7\20250417-112300.401-9.jpg)

我们接下来用命令行readelf -s ./test | grep afl来验证插桩符号：![20250417-112300.401-2](D:\许洋计算机科学与技术\软件安全\作业\实验7\实验7\20250417-112300.401-2.jpg)

至此，我们创建好了我们本次测试需要用到的程序，接下来我们需要创建测试用例。

##### 创建测试用例

 首先，创建两个文件夹 in 和 out，分别存储模糊测试所需的输入和输出相关的内容。利用命令行mkdir in out，结果如下图：![20250417-112300.401-1](D:\许洋计算机科学与技术\软件安全\作业\实验7\实验7\20250417-112300.401-1.jpg)

 然后，在输入文件夹中创建一个包含字符串“hello”的文件。 命令行：echo hello> in/foo。 foo 就是我们的测试用例，里面包含初步字符串 hello。AFL会通过这个语料进行变异，构造出更多的测试用例。![20250417-112300.401-5](D:\许洋计算机科学与技术\软件安全\作业\实验7\实验7\20250417-112300.401-5.jpg)

 至此，我们就创建好了测试用例，接着就是启动模糊测试，然后观察结果。

##### 启动模糊测试

 我们使用如下的命令行afl-fuzz -i in -o out -- ./test @@来进行模糊测试的启动：![20250417-112300.401-6](D:\许洋计算机科学与技术\软件安全\作业\实验7\实验7\20250417-112300.401-6.jpg)

当观察到产生了一个crash时，我们去out/crashes文件夹中可以看到导致本次崩溃的输入：![20250417-112300.401-10](D:\许洋计算机科学与技术\软件安全\作业\实验7\实验7\20250417-112300.401-10.jpg)

恰为我们之前分析的“deadbeef”，验证完毕！

## **心得体会：**

1. **覆盖引导的高效性**
   AFL通过编译插桩动态监控路径覆盖，结合输入变异优先探索新路径，相比随机测试大幅提升了效率。实验中，初始输入“hello”快速变异出“deadbeef”触发崩溃，验证了覆盖反馈机制的有效性。
2. **文件变异的智能生成**
   AFL通过位翻转、字符串插入等策略生成测试用例，结合覆盖信息筛选有效样本。观察到out/crashes中精准生成的崩溃输入，体现了变异策略的针对性。
3. **工具链配置的关键性**
   实验需严格遵循流程：使用afl-gcc编译、设置输入/输出目录、通过@@传递参数。任何配置疏漏（如目录缺失）均会导致工具异常，凸显环境准备的重要性。
4. **安全测试的实践意义**
   AFL自动化暴露程序边界条件漏洞，提醒开发者重视输入验证。实验表明，即使简单代码也可能因未预期输入崩溃，模糊测试是防御性编程的重要补充。
